## はじめに

カート内商品の合計を確定し注文レコードを作成する機能を追加する章です。

## 目的

カート内の全商品を1回の操作で注文化しカートを空にして注文ページへ遷移する状態を実装する。

## 課題A：注文確定アクションの実装（12分）

12分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様
カート内容を注文テーブルへ移しカートを空にして注文ページへ遷移するServer Actionを追加する。

- カート行を取得し空なら即遷移し、それ以外は注文と注文アイテム作成後にカートを削除し再検証して遷移させるServer Actionを作る。
- 対象ファイルは `src/lib/actions.ts`。新規関数 `placeOrderAction` を追加する。
- 固定ユーザーIDは `tempUserId()` で `demo-user` を得て全処理で再利用する。
- `cart_items` から `id` `product_id` `quantity` `products(price)` を `temp_user_id='demo-user'` 条件で全件取得する。
- 取得結果が0件なら `/orders?empty=1` へ `redirect` する。
- `orders` に `{ temp_user_id: 'demo-user' }` を挿入し `id` を取得する。
- カート行をマッピングし各`{ order_id, product_id, quantity, price_at_order }`を作り`order_items`へ一括挿入する（`price_at_order`は価格取得不可時0）。
- 注文アイテム挿入成功後に同一ユーザー条件で `cart_items` を削除する（失敗時は削除しない）。
- 成功時は `revalidatePath('/orders')` → `revalidatePath('/products')` → `revalidatePath('/cart')` の順で呼ぶ。
- 成功後は `/orders?placed=<注文id>` へ `redirect` する。
- エラー時は `console.error` で記録しカートは保持する。
- 成功/失敗どちらでも最後に `/orders` `/products` `/cart` を再検証する（重複呼び出し可）。
- 副作用完了は成功または空判定での `redirect` 発生時点とする。
- 直接の戻り値は持たない（遷移と再検証で完結）。
- 個別HTTPステータス指定は行わない。
- 使用フィールド: `cart_items(id, product_id, quantity)` `products(price)` `orders(id, temp_user_id)` `order_items(order_id, product_id, quantity, price_at_order)`。
- 利用するURL文字列: `/orders?empty=1` `/orders?placed=<注文id>`

【使用タグ】
- なし（サーバーコードのみ）

【命名】
- 関数: `placeOrderAction`
- 補助関数: `tempUserId`

【参照】
- `revalidatePath`
- `redirect`
- `createClient`
- `tempUserId`

### ヒント

- 空なら `redirect` で早期遷移
- 注文挿入は `insert(...).select('id').single()`
- 複数行マッピングで注文アイテム配列生成
- 成功時とfinallyで`revalidatePath`が重複しても問題なし
- エラー時もカート破棄は行わない（挿入失敗時の安全性）

### 解答例

```ts
'use server';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { createClient } from '@/lib/supabase/server';

function tempUserId() {
  return 'demo-user';
}

// 省略

// 以下新規追加
export async function placeOrderAction() {
  const supabase = await createClient();
  try {
    const { data: cartItems } = await supabase
      .from('cart_items')
      .select('id, product_id, quantity, products(price)')
      .eq('temp_user_id', tempUserId());
    if (!cartItems || cartItems.length === 0) {
      redirect('/orders?empty=1');
    }
    const { data: order } = await supabase
      .from('orders')
      .insert({ temp_user_id: tempUserId() })
      .select('id')
      .single();
    if (!order) {
      revalidatePath('/cart');
      revalidatePath('/products');
      revalidatePath('/orders');
      return;
    }
    type CartRow = { id: string; product_id: string; quantity: number; products: { price: number } | null };
    const orderItems = (cartItems as unknown as CartRow[]).map((c) => ({
      order_id: order.id,
      product_id: c.product_id,
      quantity: c.quantity,
      price_at_order: c.products?.price ?? 0,
    }));
    await supabase.from('order_items').insert(orderItems);
    await supabase.from('cart_items').delete().eq('temp_user_id', tempUserId());
    revalidatePath('/orders');
    revalidatePath('/products');
    revalidatePath('/cart');
    redirect(`/orders?placed=${order.id}`);
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/orders');
    revalidatePath('/products');
    revalidatePath('/cart');
  }
}

// 省略
```

## 課題B：カートページに注文確定UIを追加（8分）

8分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様
カートページに注文合計と注文確定フォームを追加し`placeOrderAction`を送信できるUIを実装する。

  - 対象ファイル: `src/app/cart/page.tsx`（既存内容へ追記・調整）
  - データ取得: 既存のサーバー関数 `getCartItems` で `cart_items(id, quantity, products(id, name, price))` を取得
  - 合計計算: 取得配列を `items` 変数に格納し `total` を価格×数量の合計で算出
  - 空表示: アイテム件数0のとき「カートは空です」テキストを表示し注文確定フォームは表示しない
  - 一覧表示: 各アイテムを`ul`→`li`で並べ`商品名`/`価格`/数量更新フォーム/削除フォームを縦方向スペース付きで表示
  - 更新フォーム: hiddenで`id`、number入力で`quantity`（最小0）を送り`updateCartItemAction`を呼ぶ
  - 削除フォーム: hiddenで`id`を送り`removeCartItemAction`を呼ぶ
  - 注文確定フォーム: アイテムが1件以上のときのみ表示し `action={placeOrderAction}` で送信ボタンテキストは「注文確定」
  - 再検証: Action成功時の再検証は`placeOrderAction`側実装に依存しUI側で追加処理をしない
  - 主要テキスト: 見出し「カート」合計表示「合計: ¥<数値>」空表示「カートは空です」ボタン「更新」「削除」「注文確定」
  - クラス設計: 各要素は余白/角丸/境界線/小さめ文字サイズを用い1要素あたりユーティリティは概ね5個以内に収める（具体クラス指定は解答例を参照し意味を本文で保証）
  - 並び順: ルート`div`→見出し`h1`→合計`p`→空表示条件付き`p`→`ul`（アイテムリスト）→条件付き注文確定`form`
  - 副作用: ページ内で追加のクライアント状態やJSイベントを作らない

【使用タグ】
  - `div`
    - `h1`
    - `p`（合計）
    - `p`（空表示条件付き）
    - `ul`
      - `li`（繰り返し）
        - `p`（商品名）
        - `p`（価格）
        - `div`（操作群）
          - `form`（数量更新）
            - `input` hidden(id)
            - `input` number(quantity)
            - `button`（更新）
          - `form`（削除）
            - `input` hidden(id)
            - `button`（削除）
  - `form`（注文確定条件付き）
      - `button`（注文確定）

【命名】
  - ページコンポーネント: `CartPage`
  - データ取得関数: `getCartItems`
  - 変数: `data` `items` `total`
  - Action関数: `updateCartItemAction` `removeCartItemAction` `placeOrderAction`

【参照】
  - `createClient`
  - `updateCartItemAction`
  - `removeCartItemAction`
  - `placeOrderAction`

### ヒント
  - Tailwindの例：`space-y-4` `text-sm` `rounded` `px-4` `bg-pink-600`
  - 数量0送信で削除ロジックが働く点を利用
  - 注文ボタンはアイテム存在条件で表示制御
  - 余白/角丸/色は最小限で可読性重視

### 解答例

```tsx
import { createClient } from '@/lib/supabase/server';
import { updateCartItemAction, removeCartItemAction, placeOrderAction } from '@/lib/actions';

export const dynamic = 'force-dynamic';

async function getCartItems() {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('cart_items')
      .select('id, quantity, products(id, name, price)')
      .eq('temp_user_id', 'demo-user')
      .order('created_at');
    if (error) throw error;
    return data;
  } catch (e) {
    throw e;
  }
}

export default async function CartPage() {
  const data = await getCartItems();
  const items = data || [];
  const total = items.reduce((sum, item) => sum + (item.products?.price || 0) * item.quantity, 0);

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-bold text-pink-600">カート</h1>
      <p className="text-sm">合計: ¥{total}</p>
      {!items.length && <p className="text-sm text-gray-500">カートは空です</p>}
      <ul className="space-y-3">
        {items.map((item) => (
          <li key={item.id} className="border p-3 rounded space-y-2">
            <p className="text-sm font-semibold">{item.products?.name}</p>
            <p className="text-xs text-gray-500">¥{item.products?.price}</p>
            <div className="flex gap-2 items-center">
              <form action={updateCartItemAction} className="flex gap-2 items-center">
                <input type="hidden" name="id" value={item.id} />
                <input
                  type="number"
                  name="quantity"
                  defaultValue={item.quantity}
                  min={0}
                  className="border px-2 py-1 rounded w-20"
                />
                <button className="bg-pink-500 text-white p-2 rounded text-xs">更新</button>
              </form>
              <form action={removeCartItemAction}>
                <input type="hidden" name="id" value={item.id} />
                <button className="bg-gray-300 p-2 rounded text-xs">削除</button>
              </form>
            </div>
          </li>
        ))}
      </ul>
      {/** 以下新規追加 */}
      {items.length > 0 && (
        <form action={placeOrderAction}>
          <button className="bg-pink-600 text-white px-4 py-1 rounded">注文確定</button>
        </form>
      )}
    </div>
  );
}
```

## 章末の確認

- 注文後: カートが空になる
- ボタン表示: アイテム0件で注文確定ボタン非表示
- 再検証: `/products` `/cart` の表示が更新

```bash
npm run dev
curl -i http://localhost:3000/cart
```
