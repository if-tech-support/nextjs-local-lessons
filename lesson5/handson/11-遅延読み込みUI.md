## はじめに

読み込み中の表示を分離し操作感を向上させる。

## 目的

`loading.tsx`と手動`<Suspense>`で非同期領域に即時フィードバックを与える。

## 学習対象のスキル

- ルート`loading.tsx`
- `<Suspense>`境界設計
- フォールバックUI最小化
- 非同期分割と再検証後の再描画

## 課題A：products用loading.tsx導入（8分）

8分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様

`/products`セグメントにローディングUIを追加する。

- 対象ファイル: 新規 `src/app/products/loading.tsx`
- 実行場所: サーバーコンポーネント
- 役割: `/products`ページのサーバーフェッチ待機中に簡潔なプレースホルダー表示
- 表示内容: ピンク色の小さめ文字で「読み込み中 ...」と1行表示
- スタイル: テキストのみ（角丸や枠は使わない）
- アニメ: 点滅アニメーション（パルス）を許可
- 禁止: 本文と同一の実データ文字列を表示
- 再利用: 追加の配列ループは用いない（固定1行表示）
- 追加命名: コンポーネント名 `LoadingProducts`

【命名】
- コンポーネント: `LoadingProducts`

【使用タグ】
- `p`（ローディング文言の1行表示）

### ヒント

- ページと同じ階層に`loading.tsx`を置くと自動適用
- プレースホルダーはテキスト1行で簡潔にする
- Tailwindの例：`animate-pulse` `text-pink-500`

### 解答例

```tsx
export default function LoadingProducts() {
  return <p className="animate-pulse text-pink-500">読み込み中...</p>;
}
```

## 課題B：orders用loading.tsx導入（8分）

8分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様

`/orders`セグメントにローディングUIを追加する。

- 対象ファイル: 新規 `src/app/orders/loading.tsx`
- 表示内容: ピンク色の小さめ文字で「注文ロード中 ...」を1行表示
- スタイル: テキストのみ（角丸や枠は使わない）
- 禁止: 実データと同じ文字列
- 追加命名: コンポーネント名 `LoadingOrders`

【命名】
- コンポーネント: `LoadingOrders`

【使用タグ】
- `p`（ローディング文言の1行表示）

### ヒント

- 構造はテキスト1行に簡略化
- Tailwindの例：`animate-pulse` `text-pink-500`

### 解答例

```tsx
export default function LoadingOrders() {
  return <p className="animate-pulse text-pink-500">注文ロード中...</p>;
}
```

## 課題C：Suspense分割最適化（10分）

10分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様

`/products`と`/orders`ページの手動`Suspense`を適切に配置し、読み込み中の文言をページごとに整える。

- 対象ファイル: `src/app/products/page.tsx` `src/app/orders/page.tsx`
- 分割方針: 新規の関数抽出は行わず、既存の構造を維持する（`/orders`は既存の`OrderHistory`を継続利用）
- Suspense構造: 親ページ内で`Suspense`を使い、読み込み中は短い文言をピンク色の小さめ文字で表示する
  - `/products`:「検索準備 ...」
  - `/orders`:「履歴取得 ...」
- 既存`OrderHistory`はそのまま利用する（重複定義しない）
- `ProductsPage`は既存のリスト表示をインラインのまま保持する
- 禁止: ページ全体を1つの巨大`Suspense`に戻す
- 禁止: 既存ビジネスロジック削除
- 追加命名: 新規なし（既存名を再利用）

【命名】
- 注文履歴コンポーネント: `OrderHistory`

【使用タグ】
- `div`（最上位コンテナー）
  - `h1`
  - `p`
  - `Suspense`
    - `div` / `ul`（一覧構造既存どおり）

【参照】
- `Suspense`
- `createClient`
- `addToCartAction`
- `placeOrderAction`
- `deleteOrderAction`

### ヒント

- 非同期関数コンポーネントは直接`await`でデータ取得
- fallback内の文言は統一
- 再利用する既存関数は重複定義しない

### 解答例

```tsx
// products/page.tsx
import { Suspense } from 'react';
import { createClient } from '@/lib/supabase/server';
import { addToCartAction } from '@/lib/actions';

export const dynamic = 'force-dynamic'; // 学習で都度最新を見やすく

async function getProductsAndCartItems() {
  try {
    const supabase = await createClient();
    const { data: products, error: productsError } = await supabase
      .from('products')
      .select('id, name, description, price')
      .order('created_at');
    const { data: cartItems, error: cartItemsError } = await supabase
      .from('cart_items')
      .select('quantity')
      .eq('temp_user_id', 'demo-user');
    if (productsError) throw productsError;
    if (cartItemsError) throw cartItemsError;
    return { products, cartItems };
  } catch (e) {
    throw e;
  }
}

export default async function ProductsPage() {
  const { products, cartItems } = await getProductsAndCartItems();
  const cartCount = cartItems.reduce((sum, item) => sum + item.quantity, 0);

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-bold text-pink-600">商品一覧</h1>
      <p className="text-xs text-gray-500">カート内: {cartCount} 点</p>
      {/* 以下新規追加 */}
      <Suspense fallback={<p className="text-pink-500">検索準備...</p>}> 
        <div className="space-y-4">
          <ul className="space-y-3">
            {products.map((product) => (
              <li key={product.id} className="border p-3 rounded space-y-1">
                <p className="font-semibold text-pink-600">{product.name}</p>
                <p className="text-xs text-gray-600">{product.description}</p>
                <p className="text-sm">¥{product.price}</p>
                <form action={addToCartAction} className="mt-1">
                  <input type="hidden" name="id" value={product.id} />
                  <button className="bg-pink-500 text-white p-2 rounded text-xs">カートに追加</button>
                </form>
              </li>
            ))}
            {!products.length && <p className="text-sm text-gray-500">該当なし</p>}
          </ul>
        </div>
      </Suspense>
    </div>
  );
}

// orders/page.tsx
import { Suspense } from 'react';
import { createClient } from '@/lib/supabase/server';
import { placeOrderAction, deleteOrderAction } from '@/lib/actions';

export const dynamic = 'force-dynamic';

async function getCartItems() {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('cart_items')
      .select('quantity, products(price)')
      .eq('temp_user_id', 'demo-user');
    if (error) throw error;
    return data;
  } catch (e) {
    throw e;
  }
}

export default async function OrdersPage() {
  const data = await getCartItems();
  const cartItems = data ?? [];
  const total = cartItems.reduce((sum, item) => sum + (item.products?.price || 0) * item.quantity, 0) || 0;

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-bold text-pink-600">注文</h1>
      <p className="text-sm">カート合計: ¥{total}</p>
      {total > 0 && (
        <form action={placeOrderAction}>
          <button className="bg-pink-600 text-white px-4 py-1 rounded">注文確定</button>
        </form>
      )}
      {/* 以下新規追加 */}
      <Suspense fallback={<p className="text-pink-500">履歴取得...</p>}>
        <OrderHistory />
      </Suspense>
    </div>
  );
}

async function getOrders() {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('orders')
      .select('id, created_at, order_items(id, quantity, price_at_order, products(id, name))')
      .eq('temp_user_id', 'demo-user')
      .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
  } catch (e) {
    throw e;
  }
}

async function OrderHistory() {
  const data = await getOrders();
  const orders = data || [];
  if (!orders.length) return <p className="text-sm text-gray-500">まだ注文はありません</p>;

  return (
    <ul className="space-y-4">
      {orders.map((order) => {
        const sum = order.order_items.reduce((sum, item) => sum + item.price_at_order * item.quantity, 0);
        return (
          <li key={order.id} className="border p-3 rounded space-y-2">
            <div className="flex justify-between items-center">
              <p className="text-xs text-gray-500">{order.id}</p>
              <form action={deleteOrderAction}>
                <input type="hidden" name="id" value={order.id} />
                <button className="bg-gray-300 p-1 rounded text-xs" title="この注文を削除">
                  削除
                </button>
              </form>
            </div>
            <ul className="space-y-1">
              {order.order_items.map((item) => (
                <li key={item.id} className="flex justify-between text-sm">
                  <span>
                    {item.products?.name} x {item.quantity}
                  </span>
                  <span>¥{item.price_at_order * item.quantity}</span>
                </li>
              ))}
            </ul>
            <p className="text-right text-sm font-semibold">計 ¥{sum}</p>
          </li>
        );
      })}
    </ul>
  );
}
```

## 章末の確認

- `/products`遷移時にプレースホルダーが先に出る
- `/orders`遷移時にプレースホルダーが先に出る
- 並列ロード中も他ページ操作がブロックされない

```bash
npm run dev
```
