## はじめに

注文一覧から不要な注文を削除できる機能を追加する。

## 目的

Server Actionsで注文を削除し一覧を再検証して即時反映させる。

## 課題A：注文削除アクションを実装（12分）

12分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様

注文を削除するServer Actionを追加する。

- 対象ファイル: `src/lib/actions.ts`
- 関数: `deleteOrderAction(formData:FormData)` 
  - 入力: `formData.get('id')` で取得する注文ID（文字列）
  - 入力: `id` が空文字または未取得の場合はリターン
  - 処理: `orders`テーブルから `temp_user_id='demo-user'` かつ `id` が一致する行を削除
  - 再検証: 処理の成否にかかわらず`finally`で`revalidatePath('/orders')`を1回呼ぶ
  - エラー処理: `try...catch` で例外捕捉し `console.error(e)` を実行
  - 返却値: なし（`void`型）

【使用タグ】
- なし（サーバーコードのため）

【命名】
- 削除アクション関数: `deleteOrderAction`
- 一時ユーザーID取得関数: `tempUserId`
- 再検証関数: `revalidatePath`
- フォームデータ引数: `formData`
- 取得ID変数: `id`

【参照】
- `revalidatePath`
- `createClient`
- `redirect`

### ヒント

- `formData.get('id')` は `FormDataEntryValue | null` を返す
- 文字列以外の場合は早期returnで終了
- Supabaseクライアントは前章で定義された`createClient()`を使う
- 削除後の手動再取得は不要（`revalidatePath`に任せる）

### 解答例

```ts
'use server';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { createClient } from '@/lib/supabase/server';

// テストユーザー識別 (本来は認証セッション利用)。
function tempUserId() {
  return 'demo-user';
}

export async function addToCartAction(formData: FormData) {
  try {
    const id = formData.get('id');
    if (typeof id !== 'string') return;
    const supabase = await createClient();
    const { data: existing, error } = await supabase
      .from('cart_items')
      .select('id, quantity')
      .eq('temp_user_id', tempUserId())
      .eq('product_id', id)
      .maybeSingle();
    if (error) throw error;

    if (existing) {
      const { error } = await supabase
        .from('cart_items')
        .update({ quantity: existing.quantity + 1 })
        .eq('id', existing.id);
      if (error) throw error;
    } else {
      const { error } = await supabase
        .from('cart_items')
        .insert({ temp_user_id: tempUserId(), product_id: id, quantity: 1 });
      if (error) throw error;
    }
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/products');
    revalidatePath('/orders');
    revalidatePath('/cart');
  }
}

export async function placeOrderAction() {
  const supabase = await createClient();
  try {
    const { data: cartItems } = await supabase
      .from('cart_items')
      .select('id, product_id, quantity, products(price)')
      .eq('temp_user_id', tempUserId());
    if (!cartItems || cartItems.length === 0) {
      redirect('/orders?empty=1');
    }
    const { data: order } = await supabase.from('orders').insert({ temp_user_id: tempUserId() }).select('id').single();
    if (!order) {
      revalidatePath('/cart');
      revalidatePath('/products');
      revalidatePath('/orders');
      return;
    }
    type CartRow = { id: string; product_id: string; quantity: number; products: { price: number } | null };
    const orderItems = (cartItems as unknown as CartRow[]).map((c) => ({
      order_id: order.id,
      product_id: c.product_id,
      quantity: c.quantity,
      price_at_order: c.products?.price ?? 0,
    }));
    await supabase.from('order_items').insert(orderItems);
    await supabase.from('cart_items').delete().eq('temp_user_id', tempUserId());
    revalidatePath('/orders');
    revalidatePath('/products');
    revalidatePath('/cart');
    redirect(`/orders?placed=${order.id}`);
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/orders');
    revalidatePath('/products');
    revalidatePath('/cart');
  }
}

export async function updateCartItemAction(formData: FormData) {
  try {
    const id = String(formData.get('id') || '');
    const quantity = Number(formData.get('quantity')) || 0;
    if (!id) return;
    const supabase = await createClient();
    if (quantity <= 0) {
      const { error } = await supabase.from('cart_items').delete().eq('id', id);
      if (error) throw error;
    } else {
      const { error } = await supabase.from('cart_items').update({ quantity }).eq('id', id);
      if (error) throw error;
    }
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/cart');
    revalidatePath('/products');
    revalidatePath('/orders');
  }
}

export async function removeCartItemAction(formData: FormData) {
  try {
    const id = String(formData.get('id') || '');
    if (!id) return;
    const supabase = await createClient();
    const { error } = await supabase.from('cart_items').delete().eq('id', id);
    if (error) throw error;
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/cart');
    revalidatePath('/products');
    revalidatePath('/orders');
  }
}

// 以下新規追加
export async function deleteOrderAction(formData: FormData) {
  try {
    const id = String(formData.get('id') || '');
    if (!id) return;
    const supabase = await createClient();
    const { error } = await supabase.from('orders').delete().eq('id', id).eq('temp_user_id', tempUserId());
    if (error) throw error;
  } catch (e) {
    console.error(e);
  } finally {
    revalidatePath('/orders');
  }
}
```

## 課題B：削除ボタンを一覧へ追加（8分）

8分ほどヒントを参考にして仕様どおりにコーディングに挑戦し、その後に解答例で確認しましょう。

### 仕様

注文一覧の各注文行に削除ボタン付きフォームを追加する。

- 対象ファイル: `src/app/orders/page.tsx`
- 対象箇所: 各注文`<li>`内ヘッダー行右端
  - フォーム構造: `<form action={deleteOrderAction}>`内にhidden `input name="id" value=注文ID`とボタン
  - ボタン文言:「削除」
  - ボタン目的:クリックで対象注文削除→一覧再描画
  - 削除後:指定注文が表示から消える
  - スタイル:背景薄い灰色（#d1d5db）角丸小さめ文字（約12px）余白上下4px左右4px
  - 配置:注文ID表示要素との横並び両端揃え
  - 制約: 余計なラッパー`div`を追加しない
  - エラー時: 例外は上位で捕捉されずコンソール出力のみ（再描画は継続）
  - 既存他要素（注文確定ボタン等）は変更しない
  - 追加命名: 新規なし（既存`deleteOrderAction`使用）

【使用タグ】
- `div`（最上位コンテナー）
  - `h1`
  - `p`
  - `form`（注文確定）
  - `ul`（注文一覧）
    - `li`（注文単位）
      - `div`（IDと削除ボタン行）
        - `p`（注文ID表示）
        - `form`（削除）
          - `input`（hidden id）
          - `button`（削除）
      - `ul`（注文アイテム一覧）
        - `li`（商品名×数量と小計）

【命名】
- 削除アクション: `deleteOrderAction`
- hidden入力名: `id`
- コンポーネント: `OrdersPage` `OrderHistory`

【参照】
- `createClient`
- `placeOrderAction`
- `deleteOrderAction`

### ヒント

- フォームは`action`属性にServer Action関数参照を直接渡す
- hidden入力は`type="hidden"`で注文IDを送る
- ボタンに`title`属性を付けると用途説明が可能
- 再検証はAction内`revalidatePath`で実行済み

Tailwindの例：
`flex` `justify-between` `items-center` `bg-gray-300` `text-xs`

### 解答例

```tsx
import { createClient } from '@/lib/supabase/server';
import { placeOrderAction, deleteOrderAction } from '@/lib/actions';

export const dynamic = 'force-dynamic';

async function getCartItems() {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('cart_items')
      .select('quantity, products(price)')
      .eq('temp_user_id', 'demo-user');
    if (error) throw error;
    return data;
  } catch (e) {
    throw e;
  }
}

export default async function OrdersPage() {
  const data = await getCartItems();
  const cartItems = data ?? [];
  const total = cartItems.reduce((sum, item) => sum + (item.products?.price || 0) * item.quantity, 0) || 0;

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-bold text-pink-600">注文</h1>
      <p className="text-sm">カート合計: ¥{total}</p>
      {total > 0 && (
        <form action={placeOrderAction}>
          <button className="bg-pink-600 text-white px-4 py-1 rounded">注文確定</button>
        </form>
      )}
      <OrderHistory />
    </div>
  );
}

async function getOrders() {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('orders')
      .select('id, created_at, order_items(id, quantity, price_at_order, products(id, name))')
      .eq('temp_user_id', 'demo-user')
      .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
  } catch (e) {
    throw e;
  }
}

async function OrderHistory() {
  const data = await getOrders();
  const orders = data || [];
  if (!orders.length) return <p className="text-sm text-gray-500">まだ注文はありません</p>;

  return (
    <ul className="space-y-4">
      {orders.map((order) => {
        const sum = order.order_items.reduce((sum, item) => sum + item.price_at_order * item.quantity, 0);
        return (
          <li key={order.id} className="border p-3 rounded space-y-2">
            <div className="flex justify-between items-center">
              <p className="text-xs text-gray-500">{order.id}</p>
              {/** 以下新規追加 */}
              <form action={deleteOrderAction}>
                <input type="hidden" name="id" value={order.id} />
                <button className="bg-gray-300 p-1 rounded text-xs" title="この注文を削除">削除</button>
              </form>
            </div>
            <ul className="space-y-1">
              {order.order_items.map((item) => (
                <li key={item.id} className="flex justify-between text-sm">
                  <span>
                    {item.products?.name} x {item.quantity}
                  </span>
                  <span>¥{item.price_at_order * item.quantity}</span>
                </li>
              ))}
            </ul>
            <p className="text-right text-sm font-semibold">計 ¥{sum}</p>
          </li>
        );
      })}
    </ul>
  );
}
```

## 章末の確認

- 削除ボタンで対象注文が即消える
- 削除後に他の注文は残る
- 削除後URLやクエリが不正に変化しない

```bash
npm run dev
```
